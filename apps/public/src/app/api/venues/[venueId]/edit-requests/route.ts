import { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '../../../../shared/database/client';\nimport { VenueEditRequestStatus } from '../../../../shared/types/age-restriction.types';\nimport { AgeRestrictionService } from '../../../../shared/services/age-restriction.service';\n\n/**\n * POST /api/venues/[venueId]/edit-requests\n * Create a new venue edit request\n */\nexport async function POST(request: NextRequest, { params }: { params: { venueId: string } }) {\n  try {\n    const { venueId } = params;\n    const body = await request.json();\n    const { requesterId, proposedChanges } = body;\n\n    if (!requesterId || !proposedChanges) {\n      return NextResponse.json(\n        { error: 'Requester ID and proposed changes are required' },\n        { status: 400 }\n      );\n    }\n\n    // Verify venue exists\n    const venue = await prisma.venue.findUnique({\n      where: { id: venueId },\n      include: { owner: true }\n    });\n\n    if (!venue) {\n      return NextResponse.json(\n        { error: 'Venue not found' },\n        { status: 404 }\n      );\n    }\n\n    // Check if requester is already the owner\n    if (venue.ownerId === requesterId) {\n      return NextResponse.json(\n        { error: 'You already own this venue' },\n        { status: 400 }\n      );\n    }\n\n    // Validate proposed changes using age restriction service\n    try {\n      AgeRestrictionService.validateVenueAgeRestrictions({\n        ageRestriction: proposedChanges.ageRestriction,\n        minorStartTime: proposedChanges.minorStartTime,\n        minorEndTime: proposedChanges.minorEndTime,\n        ages18To20StartTime: proposedChanges.ages18To20StartTime,\n        ages18To20EndTime: proposedChanges.ages18To20EndTime\n      });\n    } catch (error: any) {\n      return NextResponse.json(\n        { error: `Invalid venue configuration: ${error.message}` },\n        { status: 400 }\n      );\n    }\n\n    // Calculate expiration time (48 hours from now)\n    const expiresAt = new Date(Date.now() + 48 * 60 * 60 * 1000);\n\n    // Create edit request\n    const editRequest = await prisma.venueEditRequest.create({\n      data: {\n        venueId,\n        requesterId,\n        proposedChanges,\n        status: VenueEditRequestStatus.PENDING,\n        expiresAt\n      },\n      include: {\n        requester: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        }\n      }\n    });\n\n    return NextResponse.json(editRequest, { status: 201 });\n  } catch (error) {\n    console.error('Error creating venue edit request:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/venues/[venueId]/edit-requests\n * Get all edit requests for a venue\n */\nexport async function GET(request: NextRequest, { params }: { params: { venueId: string } }) {\n  try {\n    const { venueId } = params;\n    const url = new URL(request.url);\n    const status = url.searchParams.get('status');\n\n    // Build where clause\n    const where: any = { venueId };\n    if (status) {\n      where.status = status;\n    }\n\n    // Get edit requests\n    const editRequests = await prisma.venueEditRequest.findMany({\n      where,\n      include: {\n        requester: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        },\n        reviewedBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' }\n    });\n\n    return NextResponse.json(editRequests);\n  } catch (error) {\n    console.error('Error fetching venue edit requests:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}"