import { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '../../../../../../shared/database/client';\nimport { VenueEditRequestStatus } from '../../../../../../shared/types/age-restriction.types';\n\n/**\n * PUT /api/venues/[venueId]/edit-requests/[requestId]\n * Approve or reject a venue edit request\n */\nexport async function PUT(request: NextRequest, { params }: { params: { venueId: string; requestId: string } }) {\n  try {\n    const { venueId, requestId } = params;\n    const body = await request.json();\n    const { status, reviewedById, rejectionReason, approveChanges } = body;\n\n    if (!status || !reviewedById) {\n      return NextResponse.json(\n        { error: 'Status and reviewed by ID are required' },\n        { status: 400 }\n      );\n    }\n\n    // Verify the edit request exists and is pending\n    const editRequest = await prisma.venueEditRequest.findFirst({\n      where: {\n        id: requestId,\n        venueId,\n        status: VenueEditRequestStatus.PENDING\n      },\n      include: {\n        venue: { include: { owner: true } }\n      }\n    });\n\n    if (!editRequest) {\n      return NextResponse.json(\n        { error: 'Edit request not found or no longer pending' },\n        { status: 404 }\n      );\n    }\n\n    // Verify reviewer is the venue owner\n    if (editRequest.venue.ownerId !== reviewedById) {\n      return NextResponse.json(\n        { error: 'Only the venue owner can approve/reject edit requests' },\n        { status: 403 }\n      );\n    }\n\n    // Check if request has expired\n    if (editRequest.expiresAt.getTime() <= Date.now()) {\n      // Auto-expire the request\n      await prisma.venueEditRequest.update({\n        where: { id: requestId },\n        data: {\n          status: VenueEditRequestStatus.EXPIRED,\n          reviewedById,\n          reviewedAt: new Date()\n        }\n      });\n      \n      return NextResponse.json(\n        { error: 'Edit request has expired' },\n        { status: 400 }\n      );\n    }\n\n    // Update the edit request\n    const updatedRequest = await prisma.venueEditRequest.update({\n      where: { id: requestId },\n      data: {\n        status,\n        reviewedById,\n        reviewedAt: new Date(),\n        rejectionReason: status === VenueEditRequestStatus.REJECTED ? rejectionReason : undefined\n      },\n      include: {\n        requester: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        },\n        reviewedBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        }\n      }\n    });\n\n    // If approved, apply the changes to the venue\n    if (status === VenueEditRequestStatus.APPROVED && approveChanges) {\n      const updateData: any = {};\n      \n      // Map proposed changes to venue fields\n      if (editRequest.proposedChanges.ageRestriction !== undefined) {\n        updateData.ageRestriction = editRequest.proposedChanges.ageRestriction;\n      }\n      if (editRequest.proposedChanges.minorStartTime !== undefined) {\n        updateData.minorStartTime = editRequest.proposedChanges.minorStartTime;\n      }\n      if (editRequest.proposedChanges.minorEndTime !== undefined) {\n        updateData.minorEndTime = editRequest.proposedChanges.minorEndTime;\n      }\n      if (editRequest.proposedChanges.ages18To20StartTime !== undefined) {\n        updateData.ages18To20StartTime = editRequest.proposedChanges.ages18To20StartTime;\n      }\n      if (editRequest.proposedChanges.ages18To20EndTime !== undefined) {\n        updateData.ages18To20EndTime = editRequest.proposedChanges.ages18To20EndTime;\n      }\n      if (editRequest.proposedChanges.useVenueAgeForAllTables !== undefined) {\n        updateData.useVenueAgeForAllTables = editRequest.proposedChanges.useVenueAgeForAllTables;\n      }\n\n      // Update the venue\n      await prisma.venue.update({\n        where: { id: venueId },\n        data: updateData\n      });\n    }\n\n    return NextResponse.json(updatedRequest);\n  } catch (error) {\n    console.error('Error updating venue edit request:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * DELETE /api/venues/[venueId]/edit-requests/[requestId]\n * Cancel a venue edit request (can only be done by the requester)\n */\nexport async function DELETE(request: NextRequest, { params }: { params: { venueId: string; requestId: string } }) {\n  try {\n    const { venueId, requestId } = params;\n    const url = new URL(request.url);\n    const requesterId = url.searchParams.get('requesterId');\n\n    if (!requesterId) {\n      return NextResponse.json(\n        { error: 'Requester ID is required' },\n        { status: 400 }\n      );\n    }\n\n    // Verify the edit request exists and belongs to the requester\n    const editRequest = await prisma.venueEditRequest.findFirst({\n      where: {\n        id: requestId,\n        venueId,\n        requesterId,\n        status: VenueEditRequestStatus.PENDING\n      }\n    });\n\n    if (!editRequest) {\n      return NextResponse.json(\n        { error: 'Edit request not found or cannot be cancelled' },\n        { status: 404 }\n      );\n    }\n\n    // Update status to cancelled\n    await prisma.venueEditRequest.update({\n      where: { id: requestId },\n      data: {\n        status: VenueEditRequestStatus.REJECTED, // Using REJECTED for cancelled requests\n        reviewedById: requesterId,\n        reviewedAt: new Date(),\n        rejectionReason: 'Cancelled by requester'\n      }\n    });\n\n    return NextResponse.json({ message: 'Edit request cancelled successfully' });\n  } catch (error) {\n    console.error('Error cancelling venue edit request:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}"